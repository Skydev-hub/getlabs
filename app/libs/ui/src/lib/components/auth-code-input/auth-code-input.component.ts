import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { Component, forwardRef } from '@angular/core';
import { AbstractControl, ControlValueAccessor, FormArray, FormBuilder, FormGroup, NG_VALUE_ACCESSOR } from '@angular/forms';
import { FormInputMaskTypes } from '../../utils/form.utils';


@Component({
  selector: 'app-auth-code-input',
  templateUrl: './auth-code-input.component.html',
  styleUrls: ['./auth-code-input.component.scss'],
  providers: [
    {
      provide: NG_VALUE_ACCESSOR,
      useExisting: forwardRef(() => AuthCodeInputComponent),
      multi: true,
    }
  ],
})
export class AuthCodeInputComponent implements ControlValueAccessor {

  public form: FormGroup;

  public digitMask = FormInputMaskTypes.digitMask;

  autofill: string = '';

  constructor(private fb: FormBuilder) {
    this.form = fb.group({
      digits: fb.array([
        [],   // Digit 1
        [],   // Digit 2
        [],   // Digit 3
        [],   // Digit 4
        [],   // Digit 5
        []    // Digit 6
      ])
    });
  }

  get digits(): AbstractControl[] {
    return (this.form.get('digits') as FormArray).controls;
  }

  onPaste(event: ClipboardEvent) {
    // Sanitize the input - remove all non-digits
    this.writeValue(event.clipboardData.getData('text').replace(/[^\d]/g, ''));
  }

  /**
   * @description
   * Event handler for (input) - if the input event is fired by an autofill event (which is identified by an instance of CustomEvent), this method will manage the incoming set of
   * autofill characters.
   */
  interceptAutofill(event: any) {
    const val = event.target.value;

    /* We can detect autofill events on Safari by their type - CustomEvent...  If this is generated by chrome, it will be the full
     * string all at once. */
    if (event instanceof CustomEvent || val.length > 1) {
      /* Track the value of the autofill operation in progress, and clear the field targeted by the event... */
      this.autofill += event.target.value;
      this.getInputField(event.target).setValue('');

      /* When we reach max characters, write the value to the control. */
      if (this.autofill.length === Object.keys(this.digits).length) {
        this.writeValue(this.autofill);
        this.autofill = '';
      }
    } else if (event.inputType === 'insertText') {
      /* Otherwise, this is a standard input case - defer to key event handler  */
      this.handleKeyAction(event.data, event);
    }
  }

  /**
   * @description
   * Retrieves the index of the supplied target/control in the form controls set.
   */
  private getInputFieldIdx(target: EventTarget | AbstractControl) {
    /* Resolve an index that maps to the target of the supplied event.
     * This is unfortunately necessary to type as any as nativeElement isn't exposed on any interface (that I know of at the moment...) */
    return this.digits.findIndex((f: any) => {
      if (target instanceof AbstractControl) {
        return f === target;
      } else {
        return f.nativeElement === target;
      }
    });
  }

  /**
   * @description
   * Retrieves the AbstratControl element that represents the supplied target.  If the delta parameter is specified, this method will seek the control located at the supplied
   * offset of the supplied target.
   */
  private getInputField(target: EventTarget | AbstractControl, delta?: number): AbstractControl {
    /* Resolve an index that maps to the target of the supplied event.
     * This is unfortunately necessary to type as any as nativeElement isn't exposed on any interface (that I know of at the moment...) */
    let fieldIdx = this.getInputFieldIdx(target);

    /* If delta is supplied, find the element that corresponds with the specified offset.  In this case, the result will never be in an undefined range, as we bound the result to
     * the bounds of the fields. */
    fieldIdx = coerceBooleanProperty(delta) ? Math.min(Math.max(fieldIdx + delta, 0), this.digits.length - 1) : fieldIdx;

    /* If the above process did not resolve an index, throw an exception. */
    if (fieldIdx < 0 || !this.digits[fieldIdx]) {
      throw new Error('Cannot resolve an active field from the supplied event; the supplied event target is ' + target);
    }

    return this.digits[fieldIdx];
  }

  onKeydown(event: KeyboardEvent) {
    this.handleKeyAction(event.key, event);
  }

  handleKeyAction(key: string, event: Event) {
    const field = this.getInputField(event.target);

    if (key === 'Backspace' && !field.value) {
      /* Backspace processing - What backspace does depends on the contents of this field... */
      /* If the current field does not have a value: move to the previous field, and erase that value.  */
      event.preventDefault();

      setTimeout(() => {
        const lastField = this.getInputField(field, -1);

        lastField.setValue(null);
        this.focusField(lastField);
      }, 0);

    } else if (['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'].includes(key)) {
      /* Standard digit processing */
      // iOS compatibility - the focusField timeout will somehow run before the event's native action.
      event.preventDefault();
      field.setValue(key);

      setTimeout(() => this.focusField(field, 1), 0);

    }  else if (key === 'ArrowRight' || key === 'ArrowLeft') {
      /* Arrow right / arrow left keys - moves the focus to the field to the left/right */
      setTimeout(() => this.focusField(field, key === 'ArrowRight' ? 1 : -1));
    }
  }

  /**
   * @description
   * Sets the focus on the supplied field.  If a delta number is supplied, this method will set focus on the field positioned in the supplied offset from the supplied field.
   */
  focusField(targetOrField: EventTarget | AbstractControl, delta?: number) {
    const field: AbstractControl = targetOrField instanceof EventTarget || coerceBooleanProperty(delta) ? this.getInputField(targetOrField, delta) : targetOrField;

    if (field) {
      // @ts-ignore
      field.nativeElement.focus();
    }
  }

  registerOnChange(fn: any): void {
    this.form.valueChanges.subscribe(data => fn(data && data.digits ? data.digits.join('') : null));
  }

  registerOnTouched(fn: any): void {

  }

  setDisabledState(isDisabled: boolean): void {
    if (isDisabled) {
      this.form.disable();
    } else {
      this.form.enable();
    }
  }

  writeValue(code: string): void {
    if (typeof code === 'string') {
      this.digits[0].setValue(code[0] || null);
      this.digits[1].setValue(code[1] || null);
      this.digits[2].setValue(code[2] || null);
      this.digits[3].setValue(code[3] || null);
      this.digits[4].setValue(code[4] || null);
      this.digits[5].setValue(code[5] || null);
    }
  }

  /**
   * @description
   * Erases the contents of all the fields, and sets focus back to the first element.
   */
  resetControl(): void {
    /* Clear the contents of the form */
    this.writeValue('');

    /* Put focus on the first field. */
    setTimeout(() => (this.digits[0] as any).nativeElement.focus());
  }

}
